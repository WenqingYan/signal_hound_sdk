<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SM API: SM200 and SM435 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sh-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">SM API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SM200 and SM435 API Reference </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Examples</a></li>
<li class="level1"><a href="#autotoc_md1">Measurements</a></li>
<li class="level1"><a href="#autotoc_md2">Build/Version Notes</a></li>
<li class="level1"><a href="#autotoc_md3">PC Requirements</a><ul><li class="level2"><a href="#autotoc_md4">Windows Development Requirements</a></li>
<li class="level2"><a href="#autotoc_md5">Linux Development Requirements</a></li>
<li class="level2"><a href="#autotoc_md6">Other Requirements</a></li>
</ul>
</li>
<li class="level1"><a href="#refLevelAndSensitivity">Reference Level and Sensitivity</a></li>
<li class="level1"><a href="#gpsAndTimestamps">GPS and Timestamps</a><ul><li class="level2"><a href="#gpsLock">Acquiring GPS Lock</a></li>
<li class="level2"><a href="#autotoc_md7">GPS Time Stamping</a></li>
<li class="level2"><a href="#autotoc_md8">GPS Disciplining</a></li>
<li class="level2"><a href="#writingToGPS">Writing Messages to the GPS</a></li>
</ul>
</li>
<li class="level1"><a href="#gpio">GPIO</a><ul><li class="level2"><a href="#gpioSweeps">GPIO Sweeps</a><ul><li class="level3"><a href="#autotoc_md9">Inter-sweep</a></li>
<li class="level3"><a href="#autotoc_md10">Intra-sweep</a><ul><li class="level4"><a href="#autotoc_md11">Switch Resolution</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#gpioSwitching">GPIO Switching (I/Q Streaming)</a></li>
<li class="level2"><a href="#spi">SPI</a></li>
</ul>
</li>
<li class="level1"><a href="#sm435IFOutputOption">SM435 IF Output Option</a></li>
<li class="level1"><a href="#powerStates">Power States</a></li>
<li class="level1"><a href="#autotoc_md12">Thread Safety</a></li>
<li class="level1"><a href="#autotoc_md13">Multiple Devices and Multiple Processes</a></li>
<li class="level1"><a href="#linuxNotes">Linux Notes</a><ul><li class="level2"><a href="#autotoc_md14">USB Throughput</a></li>
<li class="level2"><a href="#autotoc_md15">Multiple USB Devices</a></li>
<li class="level2"><a href="#autotoc_md16">Network Devices</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md17">Programming Languages Compatibility</a></li>
<li class="level1"><a href="#iqAcquisition">I/Q Acquisiton</a><ul><li class="level2"><a href="#iqSampleRates">I/Q Sample Rates</a></li>
<li class="level2"><a href="#iqDataTypes">I/Q Data Types</a><ul><li class="level3"><a href="#autotoc_md18">Converting From Full Scale to Corrected I/Q</a></li>
</ul>
</li>
<li class="level2"><a href="#iqFiltering">I/Q Filtering and Bandwidth (USB 3.0 devices)</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md19">Estimating Sweep Size</a></li>
<li class="level1"><a href="#windowFunctions">Window Functions</a></li>
<li class="level1"><a href="#autoGPSTimebaseDiscipline">Automatic GPS Timebase Discipline</a></li>
<li class="level1"><a href="#autotoc_md20">Software Spur Rejection</a></li>
<li class="level1"><a href="#autotoc_md21">Contact Information</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="mainpage"></a></p>
<p >This documentation is a reference for the Signal Hound SM200 and SM435 (SM) spectrum analyzer programming interface (API). The API provides a set of C functions for making measurements with the SM devices. The API is C ABI compatible making is possible to be interfaced from most programming languages.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Examples</h1>
<p >All code examples are located in the <em>examples/</em> folder in the SDK which can be downloaded at <a href="www.signalhound.com/software-development-kit">www.signalhound.com/software-development-kit</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Measurements</h1>
<p >This section covers the main measurements available through the API.</p>
<ul>
<li><a class="el" href="sweep_mode.html">Sweep Mode</a></li>
<li><a class="el" href="real_time.html">Real-Time Spectrum Analysis</a></li>
<li><a class="el" href="iq_streaming.html">I/Q Streaming</a></li>
<li><a class="el" href="iq_sweep_list.html">I/Q Sweep List / Frequency Hopping</a></li>
<li><a class="el" href="iq_segmented.html">I/Q Segmented Captures</a></li>
<li><a class="el" href="iq_full_band.html">I/Q Full Band</a></li>
<li><a class="el" href="iq_v_r_t.html">I/Q Streaming (VRT)</a></li>
</ul>
<p >Also see <a class="el" href="basic_a_p_i_usage.html">Basic API Usage</a> for more information.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Build/Version Notes</h1>
<p >Versions are of the form <em>major.minor.revision</em>.</p>
<p >A <em>major</em> change signifies a significant change in functionality relating to one or more measurements, or the addition of significant functionality. Function prototypes have likely changed.</p>
<p >A <em>minor</em> change signifies additions that may improve existing functionality or fix major bugs but make no changes that might affect existing user’s measurements. Function prototypes can change but do not change existing parameters meanings.</p>
<p >A <em>revision</em> change signifies minor changes or bug fixes. Function prototypes will not change. Users should be able to update by simply replacing the .DLL/.so.</p>
<ul>
<li>Version 2.3.0 - Support for SM435C.</li>
<li>Version 2.2.0 – Support for SM435B.</li>
<li>Version 2.1.0 – Support for SM200C.</li>
<li>Version 2.0.0 – Support for SM200B, LTE I/Q sample rates, and segmented I/Q captures.</li>
<li>Version 1.1.2 – First release with support for Linux operating systems (libusb backend)</li>
<li>Version 1.0.3 – Official release, support for SM200A</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
PC Requirements</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Windows Development Requirements</h2>
<ul>
<li>Windows 10/11 (Recommended)</li>
<li>Windows 7/8 (Minimum)</li>
<li>Windows C/C++ development tools and environment.<ul>
<li>API was compiled using VS2012 and VS2019.<ul>
<li>VS2012/VS2019 C++ redistributables are required.</li>
</ul>
</li>
</ul>
</li>
<li>Library files <a class="el" href="sm__api_8h.html" title="API functions for the SM435/SM200 spectrum analyzers.">sm_api.h</a>, sm_api.lib, and sm_api.dll</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Linux Development Requirements</h2>
<ul>
<li>Linux 64-bit<ul>
<li>Ubuntu 18.04/20.04</li>
<li>CentOS 7</li>
<li>Red Hat 7</li>
</ul>
</li>
<li>libusb-1.0</li>
<li>System GCC compiler</li>
<li>SM library files, <a class="el" href="sm__api_8h.html" title="API functions for the SM435/SM200 spectrum analyzers.">sm_api.h</a> and libsm_api.so</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Other Requirements</h2>
<p >See the 10GbE network configuration guide for setting up a 10GbE network for SM200C/SM435C operation.</p>
<ul>
<li>SM200A, SM200B, SM435B<ul>
<li>USB 3.0 connectivity provided through 4th generator or later Intel CPUs. 4th generation Intel CPU systems might require updating USB 3.0 drivers to operate properly.</li>
<li>(Recommended) Quad core Intel i5 or i7 processor, 4th generation or later.</li>
<li>(Minimum) Dual core Intel i5 or i7 processor, 4rd generation or later.</li>
</ul>
</li>
<li>SM200C, SM435C<ul>
<li>10GbE connectivity with SFP+ connector and fiber cable.</li>
<li>10GbE connectivity provided through NIC adapter card or Thunderbolt 3 to SFP+ adapter.</li>
<li>(Recommended) Quad core Intel i7 processor, 8th generation or later.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="refLevelAndSensitivity"></a>
Reference Level and Sensitivity</h1>
<p >There are two ways to set the sensitivity of the receiver, through the attenuator or the reference level. (<a class="el" href="sm__api_8h.html#a70b52a402cac9cf077a879be3ba10c70">smSetAttenuator</a>/<a class="el" href="sm__api_8h.html#a9bedf092587ad08783672b8e455601a4">smSetRefLevel</a>) The <a class="el" href="sm__api_8h.html#a70b52a402cac9cf077a879be3ba10c70">smSetAttenuator</a> function allows direct control of the sensitivity. If the attenuator is set to auto, then the API chooses the best attenuator value based on the reference level selected. The attenuator is set to auto by default.</p>
<p >The reference level setting will automatically adjust the sensitivity to have the most dynamic range for signals at or near (~5dB) below the reference level. If you know the expected input signal level of your signal, setting the reference level to 5dB above your expected input will provide the most dynamic range. Using the reference level, you can also ensure the receiver does not experience an ADC overload by setting a reference level well above input signal level ranges.</p>
<p >The reference level parameter is the suggested method of controlling the receiver sensitivity.</p>
<h1><a class="anchor" id="gpsAndTimestamps"></a>
GPS and Timestamps</h1>
<p >The internal GPS communicates to the API on initialization, during all active measurements, and when requested through the <a class="el" href="sm__api_8h.html#a695812e06da1b2035b29ad4c80b968d9">smGetGPSInfo</a> function. It does not perform active communication to the PC at any time other than these.</p>
<p >NMEA sentences are updated once per second and timestamps are updated every time the GPS has a chance to communicate with the PC. This means, several consecutive sweeps within a 1 second frame have the chance to update the NMEA information at most once, and a provide a new timestamp for each sweep.</p>
<h2><a class="anchor" id="gpsLock"></a>
Acquiring GPS Lock</h2>
<p >The GPS will automatically lock with no external assistance. You can query the state of the GPS lock with either the <a class="el" href="sm__api_8h.html#af6ba503b97b185e5ce0d08c8ff082824">smGetGPSState</a> function, or by examining the return status of <a class="el" href="sm__api_8h.html#a695812e06da1b2035b29ad4c80b968d9">smGetGPSInfo</a>. From a cold start, expect a lock within the first few minutes. A warm or hot start should see a lock much quicker.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
GPS Time Stamping</h2>
<p >When the GPS is locked, I/Q data and sweep timestamping occurs using the internal GPS PPS signal and NMEA information. Once GPS lock is achieved, GPS timestamping occurs immediately and required no user intervention. Until the GPS is locked, timestamping occurs with the system clock, which has a typical accuracy of +/- 16ms.</p>
<p >If the GPS loses lock, the timestamps will advance at the nominal rate until the GPS achieves lock again. Off GPS lock timestamps will be coherent between measurement reconfigurations until the device is closed through the API or the device loses power.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
GPS Disciplining</h2>
<p >The system GPS can be in one of three states,</p>
<ol type="1">
<li>GPS unlocked – Either the GPS antenna is disconnected or is connected and hasn’t achieved lock yet. After connecting the antenna expect several minutes for the lock. If you do not see a lock after several minutes, you might need to reposition the antenna.</li>
<li>GPS locked – The GPS has achieved lock. At this point measurement timestamps will have full accuracy and geolocation information can be queried.</li>
<li>GPS disciplined – The GPS has disciplined the timebase and is updating the holdover values. (See the Spike user manual for more information about GPS holdover values)</li>
</ol>
<p >The current GPS state can be queried with <a class="el" href="sm__api_8h.html#af6ba503b97b185e5ce0d08c8ff082824">smGetGPSState</a>. If the device is actively making measurements the recommended way to wait for lock/discipline is by querying the GPS state after each measurement. If the device is idle (after an <a class="el" href="sm__api_8h.html#a7ac2877ac421ad657a27cd674d00b9b7">smAbort</a>) the recommended method is to query the GPS state in a busy loop, preferably with a small wait between queries, something like 1 second is adequate. (careful! it may never break out of a loop if you break on lock detect and the SM cannot achieve it)</p>
<p >The GPS will lock automatically with a GPS antenna attached, but for the GPS to discipline the SM, it must first be enabled. To enable GPS disciplining, use the <a class="el" href="sm__api_8h.html#ae94886f97c3249726e3ba42d776c208c">smSetGPSTimebaseUpdate</a> function. Below is the state machine for GPS disciplining. To summarize, the timebase is adjusted by the newer of the two correction factors, either the last GPS holdover value or the last Signal Hound calibration value. Only after enabling the GPS disciplining will the SM utilize a GPS lock to discipline the SM and store holdover values.</p>
<div class="image">
<img src="gps_discipline_api.png" alt=""/>
<div class="caption">
GPS Disciplining State Machine</div></div>
    <h2><a class="anchor" id="writingToGPS"></a>
Writing Messages to the GPS</h2>
<p >Using the API, customers can write custom messages to the internal u-blox M8 GPS receiver. The user can also retrieve responses to these messages. The two functions that enable this are <a class="el" href="sm__api_8h.html#ae9bc5c005135aaa3d346e241353b48cc">smWriteToGPS</a> (writing) and <a class="el" href="sm__api_8h.html#a695812e06da1b2035b29ad4c80b968d9">smGetGPSInfo</a> (reading). See these functions for more information.</p>
<p >This functionality is only available on receivers with the following firmware versions or newer.</p>
<p ><code>SM200A: 4.5.10, SM200B: 4.5.13, SM200C: 6.6.4, SM435B: All, SM435C: All</code></p>
<p >Devices with this functionality will be referred to as devices with “GPS write” functionality in this document.</p>
<p >All messages sent to the GPS are sent over port 4 (SPI). This is the only port the customer has access to. UBX and NMEA messages can be sent. All messages are documented in the u-blox M8 GPS manual. Messages must match the frame structure documented in the u-blox manual. For example, to send a UBX message, the sync chars, class, ID, length, payload (if present), and 2-byte checksum must all be present and in the correct order in the provided message.</p>
<p >An example message for a “Get” UBX-CFG-NAV5 msg with empty payload is</p>
<p ><code>msg[8] = {0xB5, 0x62, 0x06, 0x24, 0x0, 0x0, 0x2A, 0x84};</code></p>
<p >Responses are returned with the NMEA sentences through the <a class="el" href="sm__api_8h.html#a695812e06da1b2035b29ad4c80b968d9">smGetGPSInfo</a> function. Responses must be parsed by the customer and can appear anywhere in the NMEA response buffer, including being split between buffers (rare).</p>
<p >To retrieve a response, call <a class="el" href="sm__api_8h.html#a695812e06da1b2035b29ad4c80b968d9">smGetGPSInfo</a> with an adequately sized nmea buffer until the updated parameter is set to true, then parse the response for your message. The device does not have to have GPS lock to retrieve a response message.</p>
<p >See the SM C++ examples for a full example of sending and retrieving UBX messages.</p>
<p >A link to the u-blox M8 manual and protocol specification is below.</p>
<p ><a href="https://www.u-blox.com/sites/default/files/products/documents/u-blox8-M8_ReceiverDescrProtSpec_%28UBX-13003221%29.pdf">https://www.u-blox.com/sites/default/files/products/documents/u-blox8-M8_ReceiverDescrProtSpec_%28UBX-13003221%29.pdf</a></p>
<h1><a class="anchor" id="gpio"></a>
GPIO</h1>
<p >On the front panel of the SM there is a DB15 port which provides up to 8 digital logic lines available for immediate read inputs, or output lines as immediate write pins, or configurable through the API to be able to switch during sweeps and I/Q streaming.</p>
<p >Primary use cases for GPIO pins might be controlling an antenna assembly (switching between antennas) or interfacing attenuators.</p>
<div class="image">
<img src="gpio.png" alt=""/>
<div class="caption">
Front panel Female DB15 Port</div></div>
    <p ><b>Pinout</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Pin   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Pin   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">GPIO(0)   </td><td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">GPIO(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">GPIO(2)   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">GPIO(3)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Vdd in (1.8 to 3.3V)   </td><td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">3.3V out (max 30 mA)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">GND   </td><td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">SPI SCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">SPI MOSI   </td><td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">SPI MISO    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">SPI Select   </td><td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">GPIO(4)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">GPIO(5)   </td><td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">GPIO(6)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">GPIO(7)   </td><td class="markdownTableBodyNone">Shell   </td><td class="markdownTableBodyNone">GND   </td></tr>
</table>
<p >GPIO pins are grouped into two nibbles (4-bits), GPIO pins [0,1,2,3] and GPIO pins [4,5,6,7]. Each nibble can be set to either read or write pins using the <a class="el" href="sm__api_8h.html#ae62c608cb2d9301355522b8a9e37f904">smSetGPIOState</a> function. You can read or write pins using the <a class="el" href="sm__api_8h.html#a72ea1b76664d56bf04a8a284f17b2310">smWriteGPIOImm</a> or <a class="el" href="sm__api_8h.html#aa4d4911a93c962723306f49c93e072ff">smReadGPIOImm</a> functions. These functions can only be called when the device is in an idle state.</p>
<p >Additionally, there are two high speed pin switching modes that you can take advantage of. See the <a class="el" href="index.html#gpioSweeps">GPIO Sweeps</a> and <a class="el" href="index.html#gpioSwitching">GPIO Switching (I/Q Streaming)</a> sections for more information.</p>
<p >See the C++ code examples for using the set/get immediate functions.</p>
<h2><a class="anchor" id="gpioSweeps"></a>
GPIO Sweeps</h2>
<p >GPIO can utilized in 2 ways with sweeps, inter-sweep, and intra-sweep. Inter-sweep GPIO changes occur in between sweeps. This can be used to change the GPIO up to a maximum of once per sweep. Intra-sweep GPIO changes occur during sweeps and is used to change the GPIO at fixed frequencies during a sweep.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Inter-sweep</h3>
<p >Inter-sweep GPIO switching allows for rapidly sweeping a frequency range and modifying the GPIO pins for each sweep.</p>
<p >Inter-sweep GPIO changes are supported with the fast sweep speed and queued sweeps only. Using the <a class="el" href="sm__api_8h.html#a49d56ae0edbafaa6da6df00c5854db84">smSetSweepGPIO</a> function you can associate a GPIO setting with a given sweep. When the sweep is started the GPIO is changed just prior to the sweep occurring. There is ~20 microseconds between the GPIO change and the sweep starting.</p>
<p >If inter-sweep GPIO changes are needed with normal sweep speed, avoid queued sweeps and write new GPIO settings using the <a class="el" href="sm__api_8h.html#a72ea1b76664d56bf04a8a284f17b2310">smWriteGPIOImm</a> function in between sweeps.</p>
<p >See the <a class="el" href="sm__api_8h.html#a49d56ae0edbafaa6da6df00c5854db84">smSetSweepGPIO</a> function description and code examples for more information.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Intra-sweep</h3>
<p >The GPIO output pins can be configured to automatically update as the device sweeps across a specified frequency range. As the device sweeps across frequency and crosses user defined frequency boundaries, the GPIO can output specific values. The frequency boundaries and GPIO output settings are configured with <a class="el" href="sm__api_8h.html#a6bf4e5bc675064e167f99732567d77ee">smSetGPIOSweep</a>.</p>
<p >This functionality is useful for controlling an antenna assembly while very quickly sweeping a large frequency range. For instance, using the GPIO to switch between different antennas to be used for different frequencies as the SM sweeps the configured span. This would be much faster than individually sweeping each antenna manually.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
Switch Resolution</h4>
<p >Due to the digital nature of the SM device, there is a limit on the resolution on which the GPIO can change for GPIO sweeps. In normal sweep mode, the SM is processing spectrum in 39.0625MHz LO steps. This means the frequency resolution at which the GPIO can switch is 39.0625MHz. In fast sweep mode, the LO step size and GPIO switch resolution is increased to 156.25MHz.</p>
<p >This means the GPIO will not switch at the precise frequency you provide. The API is deterministic in choosing which frequencies to switch at, meaning, the same configuration will result in the same GPIO switch frequencies.</p>
<p >The API does not output or provide the actual frequencies the device switched the GPIO at. Signal Hound recommends experimenting with your setup until you find an adequate configuration.</p>
<h2><a class="anchor" id="gpioSwitching"></a>
GPIO Switching (I/Q Streaming)</h2>
<p >The GPIO output pins can be configured to automatically switch at specific time intervals when the device is in I/Q streaming mode. In this mode, the user can configure a series of GPIO states to be output while the device is streaming I/Q data. This mode is useful for controlling antennas for DF and pseudo-doppler DF systems.</p>
<p >Up to 64 states with customizable dwell times can be configured. Dwell times can be set to a minimum of 40ns and incremented in 20ns steps. For example, a 4 antenna DF system might require a configuration like</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">GPIO Output   </th><th class="markdownTableHeadNone">Dwell time (in 20ns ticks)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">0x00   </td><td class="markdownTableBodyNone">125,000    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">0x01   </td><td class="markdownTableBodyNone">125,000    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone">125,000    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">0x03   </td><td class="markdownTableBodyNone">125,000   </td></tr>
</table>
<p >The configuration above configures the GPIO to switch between 4 states and dwell at each state for 2.5ms each. For a 4 antenna DF system, this configuration will cycle through all the antennas at 100Hz (10ms per revolution).</p>
<p >When I/Q GPIO switching is activated, the external trigger input port is disabled, and internal triggers are generated and provided in the I/Q data stream to indicate when the GPIO state has reached state zero. Triggers generated on the external trigger input port are discarded. Once GPIO switching is disable, the external trigger input is enabled again.</p>
<p >For more information about configuration see <a class="el" href="sm__api_8h.html#aec0671e28de54d7f843ff4a7a41e922a">smSetGPIOSwitching</a> and <a class="el" href="sm__api_8h.html#a6182b2a4a7c73e60ed3a49e2de0c1aba">smSetGPIOSwitchingDisabled</a>.</p>
<h2><a class="anchor" id="spi"></a>
SPI</h2>
<p >Through the front panel DB15 port the SM provides a SPI output interface. (SPI reads are not implemented, only SPI writes, See <a class="el" href="index.html#gpio">GPIO</a> for the pinout) The SPI interface can be operated as output only, with a clock rate of 5.2Mbps. Between 1-4 bytes may be output through the SPI interface. Only immediate writes are available. (Direct writes while the device is idling)</p>
<p >The clock line idles high, and data transitions on the falling edge of the clock. It can be used to write to most SPI devices where data is latched on the rising edge of the clock.</p>
<p >See the C++ examples for an example of using the SPI interface.</p>
<h1><a class="anchor" id="sm435IFOutputOption"></a>
SM435 IF Output Option</h1>
<p >The SM435 can be configured with the IF output option. When this option is present, the SM435 device can function as a mmWave downconverter from 24-43.5GHz (configurable) and outputting it on the 10MHz output port at 1.5GHz center frequency (not configurable). Detailed specifications can be found in the SM product manual.</p>
<p >When the IF output option is present, the maximum frequency of the device is limited to 40.8GHz instead of 44GHz. The user is responsible for querying for the presence of the IF output option with the <a class="el" href="sm__api_8h.html#a723cd587f54c71d4f1fefc8eb015dfa7">smHasIFOutput</a> function and limiting the upper frequency accordingly. An IF output option device can be safely tuned above 40.8GHz without risk of damage but will not properly detect signals above this frequency.</p>
<p >The IF output can be enabled with the <a class="el" href="sm__api_8h.html#a984aa8a797217a9b6a40d7c248fb7a30">smSetIFOutput</a> function. No other measurements can be active while the downconverter is active.</p>
<p >Both <a class="el" href="sm__api_8h.html#a70b52a402cac9cf077a879be3ba10c70">smSetAttenuator</a> and <a class="el" href="sm__api_8h.html#a9bedf092587ad08783672b8e455601a4">smSetRefLevel</a> can be used to control the leveling of the receiver.</p>
<h1><a class="anchor" id="powerStates"></a>
Power States</h1>
<p >The SM has 2 power states, on and standby. The device can be set to standby to save power either when the active measurement mode is idle or sweep mode (assuming no sweeps are currently active).</p>
<p >A short description of each power state is described below.</p>
<ul>
<li>smPowerStateOn, Full power state. All circuitry is enabled. Power consumption is ~30W. The device is ready to make measurements.</li>
<li>smPowerStateStandby, Estimated power consumption ~16W. Some circuitry disabled. 100ms time to return to smPowerStateOn.</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Thread Safety</h1>
<p >The SM API is not thread safe. A multi-threaded application is free to call the API from any number of threads if the function calls are synchronized (i.e. using a mutex). Not synchronizing your function calls will lead to undefined behavior.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Multiple Devices and Multiple Processes</h1>
<p >The API can manage multiple devices within one process. In each process the API manages a list of open devices to prevent a process from opening a device more than once. You may open multiple devices by specifying the serial number of the device directly or allowing the API to discover them automatically.</p>
<p >If you wish to use the API in multiple processes, it is the user’s responsibility to manage a list of devices to prevent the possibility of opening a device twice from two different processes. Two processes communicating to the same device will result in undefined behavior. One possible way to manage inter-process information is to use a named mutex on a Windows system.</p>
<p >If you wish to interface multiple devices on Linux, see the <a class="el" href="index.html#linuxNotes">Linux Notes</a>.</p>
<h1><a class="anchor" id="linuxNotes"></a>
Linux Notes</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
USB Throughput</h2>
<p >By default, Linux applications cannot increase the priority of individual threads unless ran with elevated privilege (root). On Windows this issue does not exist, and the API will elevate the USB data acquisition threads to a higher priority to ensure USB data loss does not occur. On Linux, the user will need to run their application as root to ensure USB data acquisition is performed at a higher priority.</p>
<p >If this is not done, there is a higher risk of USB data loss for streaming modes such as I/Q, real-time, and fast sweep measurements on Linux.</p>
<p >In our testing, if little additional processing is occurring outside the API, 1 or 2 devices typically will not experience data loss due to this issue. Once the user application increases the processing load or starts performing I/O such as storing data to disk, the occurrence of USB data loss increases and the need to run the application as root increases.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Multiple USB Devices</h2>
<p >There are system limitations when attempting to use multiple Signal Hound USB 3.0 devices* simultaneously on Linux operating systems. The default amount of memory allocated for USB transfers on Linux is 16MB. A single Signal Hound USB 3.0 device will stay within this allocation size, but two devices will exceed this limitation and can cause connection issues or will cause the software to crash.</p>
<p >The USB memory allocation size can be changed by writing to the file</p>
<p ><code>/sys/module/usbcore/parameters/usbfs_memory_mb</code></p>
<p >A good value would be N * 16 where N is the number of devices you plan on interfacing simultaneously. One way to write to this file is with the command,</p>
<p ><code>sudo sh -c ‘echo 32 &gt; /sys/module/usbcore/parameters/usbfs_memory_mb’</code></p>
<p >where 32 can be replaced with any value you wish. You may need to restart the system for this change to take effect.</p>
<p >*Includes both Signal Hound USB 3.0 spectrum analyzers and signal generators.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Network Devices</h2>
<p >The SDK includes an example setup script which configures the parameters discussed below.</p>
<p >MTU size must be set to 9000 to enable jumbo packets.</p>
<p >Receive side socket buffers must be large enough to account for the amount of data each device can keep in flight. While I/Q streaming, a 10GbE SM device can keep up to ~32MB of data in flight. We recommend setting the maximum receive buffer size to 50MB.</p>
<p >We recommend setting the ring buffer sizes for tx and rx to 4096. This helps reduces packet loss in certain scenarios.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Programming Languages Compatibility</h1>
<p >The SM interface is C compatible which ensures it is possible to interface the API in most languages that can call C functions. These languages include C++, C#, Python, MATLAB, LabVIEW, Java, etc. Examples of calling the API in these other languages are included in the code examples folder.</p>
<p >The API consists of several enum types, which are often used as parameters. These values can be treated as 32-bit integers when callings the API functions from other programming languages. You will need to match the enumerated values defined in the API header file.</p>
<h1><a class="anchor" id="iqAcquisition"></a>
I/Q Acquisiton</h1>
<p >This section describes several I/Q attributes common to many I/Q measurements.</p>
<h2><a class="anchor" id="iqSampleRates"></a>
I/Q Sample Rates</h2>
<p >The table below outlines the available I/Q sample rates and corresponding decimations for both the USB and networked SM devices. See the software filter limitations in the following section for more information about filtering and bandwidth.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Decimation   </th><th class="markdownTableHeadNone">Native Rate (USB 3.0) MS/s   </th><th class="markdownTableHeadNone">LTE Rate* (USB 3.0) MS/s   </th><th class="markdownTableHeadNone">Native Rate (10GbE) MS/s   </th><th class="markdownTableHeadNone">LTE Rate (10GbE) MS/s   </th><th class="markdownTableHeadNone">Downsampling (All units)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 (Minimum)   </td><td class="markdownTableBodyNone">50   </td><td class="markdownTableBodyNone">61.44   </td><td class="markdownTableBodyNone">200   </td><td class="markdownTableBodyNone">122.88   </td><td class="markdownTableBodyNone">None    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">25   </td><td class="markdownTableBodyNone">30.72   </td><td class="markdownTableBodyNone">100   </td><td class="markdownTableBodyNone">61.44   </td><td class="markdownTableBodyNone">Hardware only    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">12.5   </td><td class="markdownTableBodyNone">15.36   </td><td class="markdownTableBodyNone">50   </td><td class="markdownTableBodyNone">30.72   </td><td class="markdownTableBodyNone">Hardware only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">6.25   </td><td class="markdownTableBodyNone">7.68   </td><td class="markdownTableBodyNone">25   </td><td class="markdownTableBodyNone">15.36   </td><td class="markdownTableBodyNone">Hardware only    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">3.125   </td><td class="markdownTableBodyNone">3.84   </td><td class="markdownTableBodyNone">12.5   </td><td class="markdownTableBodyNone">7.68   </td><td class="markdownTableBodyNone">Hardware/Software    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">N = {32, 64, …}   </td><td class="markdownTableBodyNone">50 / N   </td><td class="markdownTableBodyNone">61.44 / N   </td><td class="markdownTableBodyNone">200 / N   </td><td class="markdownTableBodyNone">122.88 / N   </td><td class="markdownTableBodyNone">Hardware/Software    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4096 (Maximum)   </td><td class="markdownTableBodyNone">0.012207   </td><td class="markdownTableBodyNone">0.015   </td><td class="markdownTableBodyNone">0.048828   </td><td class="markdownTableBodyNone">0.03   </td><td class="markdownTableBodyNone">Hardware/Software   </td></tr>
</table>
<p >*These sample rates are only available in SM200As with firmware &gt;= 4.5.8, or with SM200Bs with firmware &gt;= 4.5.11 combined with API version 2.0.2 or greater. All other SM devices have the LTE sample rates.</p>
<h2><a class="anchor" id="iqDataTypes"></a>
I/Q Data Types</h2>
<p >I/Q data can be returned either as 32-bit complex floats or 16-bit complex shorts depending on the data type set in smSetIQDataType. 16-bit shorts are more memory efficient by a factor of 2 but require more effort to convert to absolute amplitudes and may be less convenient to work with.</p>
<p >When data is returned as 32-bit complex floats, the data is scaled to mW and the amplitude can be calculated by the following equation</p>
<p ><b>Sample Power (dBm) = 10.0 * log10(re*re + im*im);</b></p>
<p >Where <b>re</b> and <b>im</b> are the real and imaginary components of a single I/Q sample.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Converting From Full Scale to Corrected I/Q</h3>
<p >When data is returned as 16-bit complex shorts, the data is full scale and a correction must be applied before you can measure mW or dBm. Values range from [-32768 to +32767]. To measure the power of a sample using the complex short data type, three steps are required.</p>
<ol type="1">
<li>Convert from short to float.<ul>
<li><code>float re32f = ((float)re16s / 32768.0);</code></li>
<li><code>float im32f = ((float)im16s / 32768.0);</code><ul>
<li>This converts the short to a float in the range of [-1.0 to +1.0]</li>
</ul>
</li>
</ul>
</li>
<li>Scale the floats by the correction value returned from smGetIQCorrection.<ul>
<li><code>re32f *= correction;</code></li>
<li><code>im32f *= correction;</code></li>
</ul>
</li>
<li>Calculate power<ul>
<li><code>Sample Power (dBm) = 10.0 * log10(re32f*re32f + im32f*im32f);</code></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="iqFiltering"></a>
I/Q Filtering and Bandwidth (USB 3.0 devices)</h2>
<p >The user can enable a baseband software filter on the I/Q data with a selectable bandwidth. If the software filter is disabled, the signal will only have been filtered by the hardware as described below.</p>
<p >The hardware uses several half-band filters to accomplish decimations 2, 4, and 8 and there is non-negligible aliasing between 0.8 and 1.0 of the sample rates. Software filtering will eliminate this aliasing at the cost of a slightly smaller cutoff frequency.</p>
<p >Most users will want to enable the software IF filter for better rejection in the stop band, as well as the convenience of a selectable IF bandwidth. Users may forgo the software filter to reduce CPU load on the PC or if custom signal conditioning is performed.</p>
<p >Software filtering is enabled by default for decimations greater than 8.</p>
<p >The table below shows the maximum available bandwidth with the filter disabled and the maximum bandwidth allowed with the filter enabled. These numbers apply for both base samples rates.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Decimation   </th><th class="markdownTableHeadNone">Usable Bandwidth (MHz) Filter Disabled   </th><th class="markdownTableHeadNone">Max Bandwidth (MHz) Filter Enabled    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">41.5   </td><td class="markdownTableBodyNone">41.5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">19.2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">9.6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">4.8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">2.5   </td><td class="markdownTableBodyNone">2.4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">1.25   </td><td class="markdownTableBodyNone">1.2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">64   </td><td class="markdownTableBodyNone">0.625   </td><td class="markdownTableBodyNone">0.6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">128   </td><td class="markdownTableBodyNone">0.3125   </td><td class="markdownTableBodyNone">0.3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">256   </td><td class="markdownTableBodyNone">0.15625   </td><td class="markdownTableBodyNone">0.15    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">512   </td><td class="markdownTableBodyNone">0.078125   </td><td class="markdownTableBodyNone">0.075    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1024   </td><td class="markdownTableBodyNone">0.039063   </td><td class="markdownTableBodyNone">0.0375    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2048   </td><td class="markdownTableBodyNone">0.019531   </td><td class="markdownTableBodyNone">0.01875    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4096   </td><td class="markdownTableBodyNone">0.009766   </td><td class="markdownTableBodyNone">0.009375   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md19"></a>
Estimating Sweep Size</h1>
<p >It is useful to understand the relationship between sweep parameters and sweep size. It is not possible to directly calculate the sweep size of a given configuration beforehand, but it is possible to estimate the sweep size to within a power of 2.</p>
<p >The equation that can be used to estimate sweep size is</p>
<p ><code>Sweep Size (est.) = (Span * WindowBW) / RBW</code></p>
<p >Where span and RBW are specified in Hz, and window bandwidth is specified in bins. Window bandwidth is the noise bandwidth of the FFT window function used. See the <a class="el" href="index.html#windowFunctions">Window Functions</a> section for more information.</p>
<h1><a class="anchor" id="windowFunctions"></a>
Window Functions</h1>
<p >Below are the window functions used in the API. The API uses zero-padding to achieve the requested RBW so the noise bandwidth in this table should not be directly used.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Window   </th><th class="markdownTableHeadNone">NoiseBandwidth (bins)   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Flat-Top   </td><td class="markdownTableBodyNone">3.77   </td><td class="markdownTableBodyNone">SRS flattop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Nuttall   </td><td class="markdownTableBodyNone">2.02   </td><td class="markdownTableBodyNone">None    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Kaiser   </td><td class="markdownTableBodyNone">1.79   </td><td class="markdownTableBodyNone">α = 3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blackman   </td><td class="markdownTableBodyNone">1.73   </td><td class="markdownTableBodyNone">α = 0.16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Chebyshev   </td><td class="markdownTableBodyNone">1.94   </td><td class="markdownTableBodyNone">α = 5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Hamming   </td><td class="markdownTableBodyNone">1.36   </td><td class="markdownTableBodyNone">α = 0.54, β = 0.46    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Gaussian6dB   </td><td class="markdownTableBodyNone">2.64   </td><td class="markdownTableBodyNone">σ = 0.1   </td></tr>
</table>
<h1><a class="anchor" id="autoGPSTimebaseDiscipline"></a>
Automatic GPS Timebase Discipline</h1>
<p >When enabled, the API will instruct the receiver to use the internal GPS PPS to discipline the 10MHz internal timebase. This disciplining process adjusts a tuning voltage which the API will then store on the PC filesystem. This stored tuning voltage will then be used by the API in the future to tune the timebase. This allows the receiver to reuse a good GPS frequency lock even when no GPS antenna is attached.</p>
<p ><b>Note</b>: The stored GPS tuning voltage will override the tuning voltage created during calibration, and in almost all cases this is preferred as the latest GPS discipline will be the best frequency tune.</p>
<p >The GPS tuning voltage is stored in the ProgramData/ folder at</p>
<p ><code>C:\ProgramData\SignalHound\cal_files\sm########gps.bin</code></p>
<p >where the # is the device serial number. Delete this file to have the API revert to using the internally stored frequency calibration.</p>
<p >Disable the automatic GPS timebase update to bypass this functionality with the <a class="el" href="sm__api_8h.html#ae94886f97c3249726e3ba42d776c208c">smSetGPSTimebaseUpdate</a> function.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Software Spur Rejection</h1>
<p >Software spur rejection can be enabled only for sweep measurement modes with the <a class="el" href="sm__api_8h.html#aa153d38752e1ea6cde23923855f76c6e">smSetSweepSpurReject</a> function.</p>
<p >When enabled, the SM device will sweep the frequency range twice using different LO and IF configurations. The two sweeps can be used to detect and eliminate spurious and mixer products generated by the hardware.</p>
<p >Software spur rejection is ideal for measuring slow moving or stationary signals of interest. It can make transient or fast-moving signals difficult to measure.</p>
<p >Software spur rejection is not as effective when sweeping the preselector frequency ranges when the preselector filters are enabled.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Contact Information</h1>
<p >For technical support, email <a href="#" onclick="location.href='mai'+'lto:'+'sup'+'po'+'rt@'+'si'+'gna'+'lh'+'oun'+'d.'+'com'; return false;">support@signalhound.com</a>.</p>
<p >For sales, email <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@si'+'gn'+'alh'+'ou'+'nd.'+'co'+'m'; return false;">sales@signalhound.com</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
